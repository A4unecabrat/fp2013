Домашно 3
===========

##Задачи##
Решенията на задачите се предават по e-mail на адрес:

> ivan.vladimirov.ivanov@gmail.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.scm*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като attachment-и в mail-a. Освен решения на задачите самият mail трябва да съдържа име и факултен номер. Успех!


### Задача 1 ###
Да се дефинира функция *count-triples*, която получава единствен аргумент n и връща броя на наредените тройки (i, j, k), където 1 <= i < j < k <= n, за които броя на делителите на i е равен на броя на делителите на j е равен на броя на делителите на k. Забележка - множеството от делители на едно число x включва 1 и самото число x.

**Сигнатура:**
```scheme
(define (count-triples n) ...)
```

**Примери:**
```scheme
(count-triples 10) -> 5
(count-triples 42) -> 665
(count-triples 64) -> 2100
```

### Задача 2 ###
Следват дефинициите на две функции от по-висок ред, които намират съответно сума и произведение на стойностите на произволна функция f, в интервала [a, b], като използват правилото за инкрементиране на поредната стойност, зададено от функцията next.

```scheme
(define (sum f a next b)
  (if (> a b)
      0
      (+ (f a) (sum f (next a) next b))))

(define (product f a next b)
  (if (> a b)
      1
      (* (f a) (product f (next a) next b))))
```

Веднъж дефинирани тези функции могат да се използват по следния начин:

```scheme
; Намира сумата на всички числа в интервала [1, 10].
(sum (lambda (x) x)
     1 
     (lambda (x) (+ x 1))
     10)

; Намира произведението на всички числа в интервала [1, 10] (или 10!).
(product (lambda (x) x)
         1
         (lambda (x) (+ x 1))
         10)
```

Оказва се, че тези две функции (sum и product) са доста сходни и тяхната реализация може да бъде обобщена в една още по-генерична функция от по-висок ред - *accumulate*.

Да се напише функция от по-висок ред *accumulate*, която да приема като аргументи: (1) функция, която да указва начина, по който да се извършва акумулацията (като например + или *), (2) базова стойност, от която да започне акумулацията (като например 0 за събиране или 1 за умножение), (3) функция, чиито стойности да се акумулират в интервала, (4) ляв край на интервала, (5) функция next чрез която да се укаже начина на инкрементиране на поредната стойност, и (6) десен край на интервала. Забележка - интервалът е затворен, като включва левия и десния край.

**Сигнатура:**
```scheme
(define (accumulate op null-value f a next b) ...)
```

Ако разполагаме с функцията *accumulate* бихме могли да реализираме функциите за сума и произведение по следния начин:

```scheme
(define (sum f a next b)
  (accumulate + 0 f a next b))

(define (product f a next b)
  (accumulate * 1 f a next b))

```

**Примери:**
```scheme

; Намира сумата на всички числа в интервала [1, 10].
(accumulate +
            0
            (lambda (x) x)
            1
            (lambda (x) (+ x 1))
            10) -> 55

; Намира произведението на всички числа в интервала [1, 10] (или 10!).
(accumulate *
            1
            (lambda (x) x)
            1
            (lambda (x) (+ x 1))
            10) -> 3628800
```



### Задача 3 ###
Да се напише функция от по-висок ред *count-pairs*, която получава два аргумента n и predicate и връща броя на наредените двойки (i, j), където 1 <= i < j <= n, за които функцията predicate дава резултат #t (true). Забележка - може да предположите, че функцията predicate е дву-аргументна функция.

**Сигнатура:**
```scheme
(define (count-pairs n predicate) ...)
```

**Примери:**
```scheme
(count-pairs 10 (lambda (x y) #t)) -> 45
(count-pairs 42 (lambda (x y) #t)) -> 861
(count-pairs 10 (lambda (x y) (even? (+ x y)))) -> 20
(count-pairs 10 (lambda (x y) (odd? (+ x y))))  -> 25
```


##Препоръчани материали##

* [Structure and Intrepretation of Computer Programs](http://mitpress.mit.edu/sicp/full-text/book/book.html) - Секция [1.3](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3)
* Видео лекции на Abelson and Sussman: [Лекция3](http://www.youtube.com/watch?v=erHp3r6PbJk)


