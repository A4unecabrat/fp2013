Домашно 6
===========

##Задачи##
Решенията на задачите се предават по e-mail на адрес:

> ivan.vladimirov.ivanov@gmail.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.scm*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като attachment-и в mail-a. Освен решения на задачите самият mail трябва да съдържа име и факултен номер. Успех!


### Задача 1 ###
Една от основните функции от по-висок ред за работа със списъци е фунцкцията *map*:

```scheme
(map square '(1 2 3 4)) -> (1 4 9 16)
```

Тя приема като аргументи функция и списък и връща като резултат нов списък, чийто i-ти елемент е резултатът от прилагане на функцията върху i-тия елемент на входния списък.

Да се дефинира модифициран вариант на *map*, наречен *tree-map*, който да работи със списъци, които могат да съдържат други списъци като елементи (т.е. дървета). За разлика от *map*, *tree-map* прилага входната си функция само върху атомарните елементи независимо от тяхната дълбочина в списъка (т.е. листата на дървото).

**Сигнатура:**
```scheme
(define (tree-map f tree) ...)
```

**Примери:**
```scheme
(tree-map (lambda (x) (* x x)) '((1 2) 3 (4 (5 6)))) -> ((1 4) 9 (16 (25 36)))
(tree-map even? '(1 (2 (3 (3 4))))) -> (#f (#t (#f (#f #t))))
```

### Задача 2 ###
Да се дефинира функция *zip*, която получава като аргументи два списъка *list1 = (a1 a2 ... an)* и *list2 = (b1 b2 ... bn)* с еднаква дължина и връща като резултат нов комбиниран списък, чийто i-ти елемент е списъка (ai bi). Забележка - елементите на резултатния списък са списъци с два елемента а не *cons* наредени двойки.

**Сигнатура:**
```scheme
(define (zip list1 list2) ...)
```

**Примери:**
```scheme
(zip '() '()) -> ()
(zip '(1 2) '(a b)) -> ((1 a) (2 b))
(zip '(1 2 3) '(10 20 30)) -> ((1 10) (2 20) (3 30))
```

### Задача 3 ###
Да се дефинира функция *cartesian-product*, която намира [декартовото произведение](http://en.wikipedia.org/wiki/Cartesian_product) на елементите на два входни списъка. За целите на задачата декартовото произведение на два списъка *list1 = (a1 a2 ... an)* и *list2 = (b1 b2 ... bm)* е нов списък от списъци *((a1 b1) ... (a1 bm) (a2 b1) ... (a2 bm) ... ... (an b1) ... (an bm))*. Забележка - елементите на резултатния списък са списъци с два елемента а не *cons* наредени двойки.

**Сигнатура:**
```scheme
(define (cartesian-product list1 list2) ...)
```

**Примери:**
```scheme
(cartesian-product '() '()) -> ()
(cartesian-product '(1 2) '(a b)) -> ((1 a) (1 b) (2 a) (2 b))
(cartesian-product '(1) '(a b c d)) -> ((1 a) (1 b) (1 c) (1 d))
```

##Препоръчани материали:##

* [Материалите](https://github.com/IvanIvanov/fp2013/blob/master/lab1/homework5/README.md#%D0%9F%D1%80%D0%B5%D0%BF%D0%BE%D1%80%D1%8A%D1%87%D0%B0%D0%BD%D0%B8-%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8) от предишното домашно.
* [Structure and Intrepretation of Computer Programs](http://mitpress.mit.edu/sicp/full-text/book/book.html) - Секция [2.2.2](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.2).

