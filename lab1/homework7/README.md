Домашно 7
===========

##Задачи##
Решенията на задачите се предават по e-mail на адрес:

> ivan.vladimirov.ivanov@gmail.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.scm*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като attachment-и в mail-a. Освен решения на задачите самият mail трябва да съдържа име и факултен номер. Успех!


### Задача 1 ###
Да се дефинира функция *const-difference*, която получава като аргументи два вектора с еднаква дължина и проверява дали втория вектор може да се получи от първия вектор, като към всеки негов елемент се прибави някаква константа *c*. Или *const-difference* проверява дали разликата между i-тия елемент на първия вектор и i-тия елемент на втория вектор е еднаква за всеки индекс i. За целите на тази задача векторите ще бъдат моделирани като списъци от цели числа.

**Сигнатура:**
```scheme
(define (const-difference list1 list2) ...)
```

**Примери:**
```scheme
(const-difference '(1 2 3) '(1 2 3)) -> #t
(const-difference '(1 2 3) '(11 12 13)) -> #t
(const-difference '(1 2 3) '(11 12 14)) -> #f
```

### Задача 2 ###
Да се дефинира функция *diagonal-to-matrix*, която получава списък от числа и връща като резултат квадратна матрица, чийто главен диагонал е съставен от елементите на входния списък. Всички останали елементи на матрицата трябва да имат стойност 0. За целите на тази задача матрица ще представлява списък от редове, като всеки ред е списък от числа.

**Сигнатура:**
```scheme
(define (diagonal-to-matrix diagonal) ...)
```

**Примери:**
```scheme
(diagonal-to-matrix '(1)) -> ((1))
(diagonal-to-matrix '(1 2 3)) -> ((1 0 0) (0 2 0) (0 0 3))
(diagonal-to-matrix '(1 1 1 1 1)) -> ((1 0 0 0 0) (0 1 0 0 0) (0 0 1 0 0) (0 0 0 1 0) (0 0 0 0 1))
```

### Задача 3 ###
Програмите на езика Scheme са вложени списъци. Това означава, че когато дефинираме функция, която работи с вложени списъци същата тази функция може да работи и с вложени списъци, които представляват валидни Scheme програми!

Да се дефинира функция *if-to-cond*, която получава валидна Scheme програма (списък от списъци) и връща като резултат нова валидна Scheme програма (списък от списъци), във която всяко срещане на специалната форма *if* е заменено с използване на специалната форма *cond*. Може да се предположи, че специалната форма *if* винаги ще е от вида:

```scheme
(if <predicate> <consequent> <alternative>)
```

Или *if* е винаги списък от 4 елемента. Първият е символа *if*, вторият е елемента *predicate* (атом или списък), третият е елемента *consequent* (атом или списък) и четвъртият е елемента *alternative* (атом или списък).

За целите на тази задача всяко срещане на *if* трябва да се замени с *cond* по следния начин: 

```scheme
(cond (<predicate> <consequent>)
      (else <alternative>))
```

**Сигнатура:**
```scheme
(define (if-to-cond program) ...)
```

**Примери:**
```scheme

(if-to-cond '(if (= foo bar) 42 7)) -> (cond ((= foo bar) 42) (else 7))

(if-to-cond '(define (fib n)
               (if (<= n 1)
                   n
                   (+ (fib (- n 1)) (fib (- n 2)))))) -> (define (fib n) (cond ((<= n 1) n) (else (+ (fib (- n 1)) (fib (- n 2))))))

(if-to-cond '(define (my-abs x)
               (if (< x 0)
                   (- x)
                   (if (= x 0)
                       0
                       x)))) -> (define (my-abs x) (cond ((< x 0) (- x)) (else (cond ((= x 0) 0) (else x)))))

```

**Упътване:**
За да проверите дали първият елемент на списък е символът *if* можа използвате вградения предикат *eq?*:

```scheme
(eq? (car program) 'if)
```

За да конструирате *cond* израз от три елемента *predicate*, *consequent* и *alternative* може да пробвате:

```scheme
(list 'cond
      (list predicate consequent)
      (list 'else alternative))
```

##Препоръчани материали:##

* [Материалите](https://github.com/IvanIvanov/fp2013/tree/master/lab1/homework6#%D0%9F%D1%80%D0%B5%D0%BF%D0%BE%D1%80%D1%8A%D1%87%D0%B0%D0%BD%D0%B8-%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8) от предишното домашно.

