# 5то упражнение - Функции от по-висок ред върху списъци

Задачи, които решавахме на 5тото упражнение.

## reduce

Функция, която приема списък, оператор на два аргумента и начална стойност и ни връща скалар (единична стойност).
Редуцира списък до единична (скаларна) стойност.

### Имплементация
```scheme
(define (reduce l oper start_value)
    (cond
        ((null? l) start_value)
        (else (reduce (cdr l) oper (oper (car l) start_value)))))
```

### Примерно използване
```scheme
    (reduce (list 1 2 3) + 0) ;;; ще сумира числата в списъка
    (reduce (list #t #f #t) (lambda (x y) (or x y)) #f) ;;; ще ни върне #t ако има поне една истина в списъка
```
## map

```map`` е функция, която приема списък и едноаргументна функция и ни връща нов спицък, където всеки елемент е извикан с дадената функция.
```map : [a1, a2, a3, ..., an], f -> [f(a1), f(a2), f(a3), ... , f(an)]```

### Имплементация с опашкова рекурсия
```scheme
(define (mymap l f)
  (define (mymap-iter l f result)
    (cond
      ( (null? l) result)
      (else (mymap-iter (cdr l) f (cons (f (car l)) result)))))
    
  (reverse (mymap-iter l f '())))
```

### Имплементация със стандартна рекурсия
```scheme
(define (mymap-rec l f)
  (cond
    ((null? l) '())
    (else (cons (f (car l)) (mymap-rec (cdr l) f)))))
```

### Примерно използване
```scheme
(mymap (list 1 2 3) (lambda (x) (* x x ))) ;;; (1 4 9)
```

## filter
```filter``` е функция, която приема списък и едноаргументен предикат и връща нов списък, който се състои само от тези елементи, за които предиката връща истина

``` filter: [a1, a2, a3], pred? -> [ai | (pred? ai) == #t]```

### Имплементация с опашкова рекурсия
```scheme
(define (filter l pred?)
  (define (filter-iter l pred? result)
    (cond
      ( (null? l) result)
      ( (pred? (car l)) (filter-iter (cdr l) pred? (cons (car l) result)))
      (else (filter-iter (cdr l) pred? result))))
  
  (reverse (filter-iter l pred? '())))
```

### Имплементация със стандартна рекурсия
```scheme
(define (filter-rec l pred?)
  (cond
    ( (null? l) '())
    ( (pred? (car l)) (cons (car l) (filter-rec (cdr l) pred?)))
    (else (filter-rec (cdr l) pred?))))
```

### Примерно използваме
```scheme
(filter (list 1 2 3 4 5 6 7 8) odd?) ;;; (1 3 5 7)
```

## sum-of-n чрез range и reduce

Идеята е да се напише ```scheme (define (sum-of-n n) ... )``` чрез ```range``` и ```reduce```

### Имплементация
```scheme
(define (sum-of-n n)
    (reduce (range 1 n) + 0))
```
## any?
```any?``` е функция, която взима списък и предикат и връща ```#t``` ако поне един елемент от списъка връща истина, подаден като аргумент на предиката.
Ако няма такъв елемент, функцията връща ```#f```

### Имплементация
```scheme
(define (any? l pred?)
  (> (length (filter l pred?)) 0))
```

## all?

```all``` е функция, която взима списък и предикат и връща ```#t``` ако всички елементи от списъка отговорят с ```#t``` на извикване с предиката.
Ако дори един елемент не отговаря на изискването в предиката, функцията връща ```#f```

### Имплементация
```scheme
(define (all? l pred?)
  (= (length (filter l pred?)) (length l)))
```

## reject

Това е обратната фукнция на ```filter```. Ако ```filter``` връща всички елементи, отговарящи с истина на предиката, то ```reject``` връща всички елемент, отговарящи с лъжа на него.

### Имплементация
Тук идеята е, че използваме вече написания filter, като подаваме lambda функция, която отрича предиката, за да ни свърши работа.

```scheme
(define (reject l pred?)
  (filter l (lambda (x) (not (pred? x)))))
```

### Примерно използваме
```scheme
(reject (range 1 10) odd?) ;;; (2 4 6 8 10)
```

## take

Функцията ```take``` приема два аргумента - ```l``` и ```n``` и връща първите ```n``` елемента на списъка ```l```

### Имплементация

Ще бъде качена скоро, за сега може да се упражните, като напишете такава :)

### Примерно използваме
```scheme
(take (range 1 10) 5) ;;; (1 2 3 4 5)
```

## drop

```drop``` е обратната на ```take``` - премахва първите n елемента от даден списък.

### Имплементация

Ще бъде качена скоро, за сега може да се упражните, като напишете такава :)

### Примерно използваме
```scheme
(drop (range 1 10) 5) ;;; (6 7 8 9 10)
```

## drop-while

drop-while приема списък и предикат и маха елементи от началото на списъка, докато предиката не върне стойност ```#f```, след което връща това, което е останало от списъка

### Имплементация

```scheme
(define (drop-while l pred?)
  (cond
    ( (null? l) (list))
    ( (not (pred? (car l))) l)
    (else (drop-while (cdr l) pred?))))
```

### Примерно използваме
```scheme
(drop-while (list 0 0 0 0 1 2 3) (lambda (x) (= x 0))) ;;; (1 2 3)
```

## remove-trailing

```scheme
(remove-trailing l n)``` 
премахва всички срещания на числото ```n```, започвайки отзад на списъка.
При първото срещане на число, различно от ```n```, функцията спира и връща останалия списък.

### Имплементация

Ще бъде качена скоро, за сега може да се упражните, като напишете такава :)

### Примерно използваме
```scheme
(remove-trailing (list 0 0 0 0 1 2 3 3 3) 3) ;;; (0 0 0 0 1 2)
```

## remove-leading

```scheme
(remove-leading l n)``` 
e като ```remove-trailing```, само че започва маханeто на даденото число ```n``` от началото на списъка.

### Имплементация

Ще бъде качена скоро, за сега може да се упражните, като напишете такава :)

### Примерно използваме
```scheme
(remove-leading (list 0 0 0 0 1 2 3 3 0 3 0) 0) ;;; (1 2 3 3 0 3 0)
```

## count-n

```scheme
(count-n l n)``` 
връща срещанията на числото ```n``` в списъка ```l```

## map-argument

```scheme
(map-argument list-of-functions x)``` 
приема списък от едноаргументи функции и цяло число ```x```, като връща нов списък, съставен от резултатът на всички функции, извикани с аргумент ```x```

## prefix?

```scheme
(prefix? l1 l2)
```
връща истина, ако списъкът ```l1``` е префикс на списъка ```l2```

## do-while

```scheme
(do-while l f pred?)``` 
взима списък и връща нов списък, който се строи по следния начин:
Функцията започва да ходи по списъка и докато ```pred?``` връща истина за поредния елемент, този елемент се заменя със стойността на ```f``` от него.

### Примерно използваме
```scheme
(do-while (list 0 0 0 2 3 4) (lambda (x) (+ x 1)) (lambda (x) (= x 0)) ) ; (1 1 1 2 3 4)
```